// Generated by CoffeeScript 1.10.0
(function() {
  'use strict';

  /** @preserve Spiderfy
  https://github.com/jawj/OverlappingMarkerSpiderfier-Leaflet
  Copyright (c) 2011 - 2012 George MacKerron
  Released under the MIT licence: http://opensource.org/licenses/mit-license
  Note: The Leaflet maps API must be included *before* this code
   */
  var cleanExtend, extend,
    slice = [].slice;

  if (this.L == null) {
    return;
  }

  this.Spiderfy = (function() {
    var p, twoPi;

    twoPi = Math.PI * 2;

    function Spiderfy(map1, opts) {
      var e, j, len, ref;
      this.map = map1;
      if (opts == null) {
        opts = {};
      }
      extend(this, opts, Spiderfy.defaultOpts);
      this.enabled = true;
      this.initMarkerArrays();
      this.listeners = {};
      if (this.offEvents && this.offEvents.length) {
        ref = this.offEvents;
        for (j = 0, len = ref.length; j < len; j++) {
          e = ref[j];
          this.map.addEventListener(e, this.deactivate.bind(this));
        }
      }
    }

    p = Spiderfy.prototype;

    p.VERSION = '0.2.6';

    p.initMarkerArrays = function() {
      this.markers = [];
      this.markerListeners = [];
      return this.bodies = [];
    };

    p.addMarker = function(marker) {
      var e, j, len, markerListener, ref;
      if (marker._oms != null) {
        return this;
      }
      marker._oms = true;
      markerListener = (function(_this) {
        return function() {
          return _this.spiderListener(marker);
        };
      })(this);
      if (this.onEvents && this.onEvents.length) {
        ref = this.onEvents;
        for (j = 0, len = ref.length; j < len; j++) {
          e = ref[j];
          marker.addEventListener(e, markerListener);
        }
      }
      this.markerListeners.push(markerListener);
      this.markers.push(marker);
      return this;
    };

    p.getMarkers = function() {
      return this.markers.slice(0);
    };

    p.removeMarker = function(marker) {
      var e, i, j, len, markerListener, ref;
      if (marker._spiderfyData != null) {
        this.deactivate();
      }
      i = this.arrIndexOf(this.markers, marker);
      if (i < 0) {
        return this;
      }
      markerListener = this.markerListeners.splice(i, 1)[0];
      if (this.onEvents && this.onEvents.length) {
        ref = this.onEvents;
        for (j = 0, len = ref.length; j < len; j++) {
          e = ref[j];
          marker.removeEventListener(e, markerListener);
        }
      }
      delete marker._oms;
      this.markers.splice(i, 1);
      return this;
    };

    p.clearMarkers = function() {
      var e, i, j, k, len, len1, marker, markerListener, ref, ref1;
      this.deactivate();
      ref = this.markers;
      for (i = j = 0, len = ref.length; j < len; i = ++j) {
        marker = ref[i];
        markerListener = this.markerListeners[i];
        if (this.onEvents && this.onEvents.length) {
          ref1 = this.onEvents;
          for (k = 0, len1 = ref1.length; k < len1; k++) {
            e = ref1[k];
            marker.removeEventListener(e, markerListener);
          }
        }
        delete marker._oms;
      }
      this.initMarkerArrays();
      return this;
    };

    p.addListener = function(event, func) {
      var base;
      ((base = this.listeners)[event] != null ? base[event] : base[event] = []).push(func);
      return this;
    };

    p.removeListener = function(event, func) {
      var i;
      i = this.arrIndexOf(this.listeners[event], func);
      if (!(i < 0)) {
        this.listeners[event].splice(i, 1);
      }
      return this;
    };

    p.clearListeners = function(event) {
      this.listeners[event] = [];
      return this;
    };

    p.trigger = function() {
      var args, event, func, j, len, ref, ref1, results;
      event = arguments[0], args = 2 <= arguments.length ? slice.call(arguments, 1) : [];
      ref1 = (ref = this.listeners[event]) != null ? ref : [];
      results = [];
      for (j = 0, len = ref1.length; j < len; j++) {
        func = ref1[j];
        results.push(func.apply(null, args));
      }
      return results;
    };

    p.generatePtsCircle = function(count, centerPt) {
      var angle, angleStep, calculatedStartAngle, circumference, i, j, legLength, ref, results;
      circumference = this.circleFootSeparation * (2 + count);
      legLength = circumference / twoPi;
      angleStep = twoPi / count;
      calculatedStartAngle = this.circleStartAngle * (Math.PI / 180);
      results = [];
      for (i = j = 0, ref = count; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
        angle = calculatedStartAngle + i * angleStep;
        results.push(new L.Point(centerPt.x + legLength * Math.cos(angle), centerPt.y + legLength * Math.sin(angle)));
      }
      return results;
    };

    p.generatePtsSpiral = function(count, centerPt) {
      var angle, i, j, legLength, pt, ref, results;
      legLength = this.spiralLengthStart;
      angle = 0;
      results = [];
      for (i = j = 0, ref = count; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
        angle += this.spiralFootSeparation / legLength + i * 0.0005;
        pt = new L.Point(centerPt.x + legLength * Math.cos(angle), centerPt.y + legLength * Math.sin(angle));
        legLength += twoPi * this.spiralLengthFactor / angle;
        results.push(pt);
      }
      return results;
    };

    p.spiderListener = function(marker) {
      var active, j, len, m, mPt, markerPt, nearbyMarkerData, nonNearbyMarkers, pxSq, ref;
      active = marker._spiderfyData != null;
      if (!this.keep) {
        if (!active) {
          this.deactivate();
        }
      }
      if (active) {
        this.trigger('click', marker);
        return this;
      } else {
        nearbyMarkerData = [];
        nonNearbyMarkers = [];
        pxSq = this.nearbyDistance * this.nearbyDistance;
        markerPt = this.map.latLngToLayerPoint(marker.getLatLng());
        ref = this.markers;
        for (j = 0, len = ref.length; j < len; j++) {
          m = ref[j];
          if (!this.map.hasLayer(m)) {
            continue;
          }
          mPt = this.map.latLngToLayerPoint(m.getLatLng());
          if (this.ptDistanceSq(mPt, markerPt) < pxSq) {
            nearbyMarkerData.push({
              marker: m,
              markerPt: mPt
            });
          } else {
            nonNearbyMarkers.push(m);
          }
        }
        if (nearbyMarkerData.length === 1) {
          return this.trigger('click', marker);
        } else if (nearbyMarkerData.length > 0 && nonNearbyMarkers.length > 0) {
          return this.activate(nearbyMarkerData, nonNearbyMarkers);
        } else {
          return null;
        }
      }
    };

    p.makeHighlightListeners = function(marker) {
      return {
        highlight: (function(_this) {
          return function() {
            return marker._spiderfyData.leg.setStyle({
              color: _this.legColors.highlighted
            });
          };
        })(this),
        unhighlight: (function(_this) {
          return function() {
            return marker._spiderfyData.leg.setStyle({
              color: _this.legColors.usual
            });
          };
        })(this)
      };
    };

    p.activate = function(markerData, nonNearbyMarkers) {
      var activeMarkers, body, bodyPt, footLl, footPt, footPts, lastMarkerCoords, leg, marker, markerCoords, md, mhl, nearestMarkerDatum, numFeet;
      if (!this.enabled) {
        return;
      }
      this.activating = true;
      numFeet = markerData.length;
      bodyPt = this.ptAverage((function() {
        var j, len, results;
        results = [];
        for (j = 0, len = markerData.length; j < len; j++) {
          md = markerData[j];
          results.push(md.markerPt);
        }
        return results;
      })());
      footPts = numFeet >= this.circleSpiralSwitchover ? this.generatePtsSpiral(numFeet, bodyPt).reverse() : this.generatePtsCircle(numFeet, bodyPt);
      lastMarkerCoords = null;
      activeMarkers = (function() {
        var j, len, results;
        results = [];
        for (j = 0, len = footPts.length; j < len; j++) {
          footPt = footPts[j];
          footLl = this.map.layerPointToLatLng(footPt);
          nearestMarkerDatum = this.minExtract(markerData, (function(_this) {
            return function(md) {
              return _this.ptDistanceSq(md.markerPt, footPt);
            };
          })(this));
          marker = nearestMarkerDatum.marker;
          markerCoords = marker.getLatLng();
          lastMarkerCoords = markerCoords;
          leg = new L.Polyline([markerCoords, footLl], {
            color: this.legColors.usual,
            weight: this.legWeight,
            clickable: false
          });
          this.map.addLayer(leg);
          marker._spiderfyData = {
            usualPosition: marker.getLatLng(),
            leg: leg
          };
          if (this.legColors.highlighted !== this.legColors.usual) {
            mhl = this.makeHighlightListeners(marker);
            marker._spiderfyData.highlightListeners = mhl;
            marker.addEventListener('mouseover', mhl.highlight);
            marker.addEventListener('mouseout', mhl.unhighlight);
          }
          marker.setLatLng(footLl);
          if (marker.hasOwnProperty('setZIndexOffset')) {
            marker.setZIndexOffset(1000000);
          }
          results.push(marker);
        }
        return results;
      }).call(this);
      delete this.activating;
      this.isActive = true;
      if (this.body && lastMarkerCoords !== null) {
        body = L.circleMarker(lastMarkerCoords, this.body);
        this.map.addLayer(body);
        this.bodies.push(body);
      }
      return this.trigger('activate', activeMarkers, nonNearbyMarkers);
    };

    p.deactivate = function(markerNotToMove) {
      var body, inactiveMarkers, j, k, len, len1, marker, mhl, nonNearbyMarkers, ref, ref1;
      if (markerNotToMove == null) {
        markerNotToMove = null;
      }
      if (this.isActive == null) {
        return this;
      }
      this.deactivating = true;
      inactiveMarkers = [];
      nonNearbyMarkers = [];
      ref = this.markers;
      for (j = 0, len = ref.length; j < len; j++) {
        marker = ref[j];
        if (marker._spiderfyData != null) {
          this.map.removeLayer(marker._spiderfyData.leg);
          if (marker !== markerNotToMove) {
            marker.setLatLng(marker._spiderfyData.usualPosition);
          }
          if (marker.hasOwnProperty('setZIndexOffset')) {
            marker.setZIndexOffset(0);
          }
          mhl = marker._spiderfyData.highlightListeners;
          if (mhl != null) {
            marker.removeEventListener('mouseover', mhl.highlight);
            marker.removeEventListener('mouseout', mhl.unhighlight);
          }
          delete marker._spiderfyData;
          inactiveMarkers.push(marker);
        } else {
          nonNearbyMarkers.push(marker);
        }
      }
      ref1 = this.bodies;
      for (k = 0, len1 = ref1.length; k < len1; k++) {
        body = ref1[k];
        this.map.removeLayer(body);
      }
      delete this.deactivating;
      delete this.isActive;
      this.trigger('deactivate', inactiveMarkers, nonNearbyMarkers);
      return this;
    };

    p.ptDistanceSq = function(pt1, pt2) {
      var dx, dy;
      dx = pt1.x - pt2.x;
      dy = pt1.y - pt2.y;
      return dx * dx + dy * dy;
    };

    p.ptAverage = function(pts) {
      var j, len, numPts, pt, sumX, sumY;
      sumX = 0;
      sumY = 0;
      for (j = 0, len = pts.length; j < len; j++) {
        pt = pts[j];
        sumX += pt.x;
        sumY += pt.y;
      }
      numPts = pts.length;
      return new L.Point(sumX / numPts, sumY / numPts);
    };

    p.minExtract = function(set, func) {
      var bestIndex, bestVal, index, item, j, len, val;
      for (index = j = 0, len = set.length; j < len; index = ++j) {
        item = set[index];
        val = func(item);
        if ((typeof bestIndex === "undefined" || bestIndex === null) || val < bestVal) {
          bestVal = val;
          bestIndex = index;
        }
      }
      return set.splice(bestIndex, 1)[0];
    };

    p.arrIndexOf = function(arr, obj) {
      var i, j, len, o;
      if (arr.indexOf != null) {
        return arr.indexOf(obj);
      }
      for (i = j = 0, len = arr.length; j < len; i = ++j) {
        o = arr[i];
        if (o === obj) {
          return i;
        }
      }
      return -1;
    };

    p.enable = function() {
      this.enabled = true;
      return this;
    };

    p.disable = function() {
      this.enabled = false;
      return this;
    };

    return Spiderfy;

  })();

  this.Spiderfy.defaultOpts = {
    keep: false,
    nearbyDistance: 20,
    circleSpiralSwitchover: 9,
    circleFootSeparation: 25,
    circleStartAngle: 1,
    spiralFootSeparation: 28,
    spiralLengthStart: 11,
    spiralLengthFactor: 5,
    legWeight: 1.5,
    legColors: {
      usual: '#222',
      highlighted: '#f00'
    },
    offEvents: ['click', 'zoomend'],
    onEvents: ['click'],
    body: {
      color: '#222',
      radius: 3,
      opacity: 0.9,
      fillOpacity: 0.9
    },
    msg: {
      buttonEnabled: 'spiderfy enabled - click to disable',
      buttonDisabled: 'spiderfy disabled - click to enable'
    },
    icon: '<svg viewBox="-100 -100 200 200" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">\n   <g id="2">\n     <g id="1">\n       <circle cy="60" r="20"/>\n       <path d="M 0,0 v 60" stroke="black" stroke-width="10"/>\n     </g>\n     <use xlink:href="#1" transform="scale(-1)"/>\n   </g>\n   <use xlink:href="#2" transform="rotate(60)"/>\n  <use xlink:href="#2" transform="rotate(-60)"/>\n</svg>'
  };

  extend = function(out) {
    var i, key;
    if (out == null) {
      out = {};
    }
    i = 1;
    while (i < arguments.length) {
      if (!arguments[i]) {
        i++;
        continue;
      }
      for (key in arguments[i]) {
        if (arguments[i].hasOwnProperty(key)) {
          out[key] = arguments[i][key];
        }
      }
      i++;
    }
    return out;
  };

  cleanExtend = function(it, using) {
    var key, out;
    out = {};
    for (key in using) {
      if (using.hasOwnProperty(key)) {
        if (it.hasOwnProperty(key)) {
          out[key] = it[key];
        } else {
          out[key] = value;
        }
      }
    }
    return out;
  };

  L.Spiderfy = L.Control.extend({
    options: extend({
      position: 'topleft',
      markers: [],
      click: null,
      activate: null,
      deactivate: null
    }, Spiderfy.defaultOpts),
    onAdd: function(map) {
      var _spiderfy, active, button, buttonDisabled, buttonEnabled, j, len, marker, ref, style;
      _spiderfy = new Spiderfy(map, cleanExtend(this.options, Spiderfy.defaultOpts));
      if (this.options.click) {
        _spiderfy.addListener('click', this.options.click);
      }
      if (this.options.activate) {
        _spiderfy.addListener('activate', this.options.activate);
      }
      if (this.options.deactivate) {
        _spiderfy.addListener('deactivate', this.options.deactivate);
      }
      active = true;
      buttonEnabled = this.options.msg.buttonEnabled;
      buttonDisabled = this.options.msg.buttonDisabled;
      button = L.DomUtil.create('a', 'leaflet-bar leaflet-control leaflet-control-spiderfy');
      button.setAttribute('href', '#');
      button.setAttribute('title', buttonEnabled);
      button.innerHTML = this.options.icon;
      style = button.style;
      style.backgroundColor = 'white';
      style.width = '30px';
      style.height = '30px';
      ref = this.options.markers;
      for (j = 0, len = ref.length; j < len; j++) {
        marker = ref[j];
        _spiderfy.addMarker(marker);
      }
      button.onclick = function() {
        if (active) {
          active = false;
          button.setAttribute('title', buttonDisabled);
          style.opacity = 0.5;
          return _spiderfy.deactivate().disable();
        } else {
          active = true;
          button.setAttribute('title', buttonEnabled);
          style.opacity = 1;
          return _spiderfy.enable();
        }
      };
      return button;
    }
  });

  L.spiderfy = function(options) {
    var spiderfy;
    spiderfy = new L.Spiderfy(options);
    map.addControl(spiderfy);
    return spiderfy;
  };

}).call(this);
